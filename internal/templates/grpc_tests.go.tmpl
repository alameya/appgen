{{define "grpc_tests"}}
// Create Tests
func (s *IntegrationTestSuite) Test{{.Name}}CreateGRPC() {
    tests := []struct {
        name        string
        request     *proto.Create{{.Name}}Request
        setupFn     func()
        wantErr     bool
        wantErrCode codes.Code
        wantErrMsg  string
        validate    func(*testing.T, *proto.{{.Name}}, error)
    }{
        // Позитивные тесты
        {
            name: "Success/ValidData",
            request: &proto.Create{{.Name}}Request{
                {{range .Fields}}
                {{if ne .Name "Id"}}
                {{.Name}}: s.generateTestData("{{.Type}}").({{.Type}}),
                {{end}}
                {{end}}
            },
            validate: func(t *testing.T, resp *proto.{{.Name}}, err error) {
                require.NoError(t, err)
                require.NotNil(t, resp)
                require.NotZero(t, resp.Id)
                {{range .Fields}}
                {{if ne .Name "Id"}}
                require.NotEmpty(t, resp.{{.Name}})
                {{end}}
                {{end}}
            },
        },
        // Негативные тесты
        {
            name:        "Error/EmptyRequest",
            request:     &proto.Create{{.Name}}Request{},
            wantErr:     true,
            wantErrCode: codes.InvalidArgument,
            wantErrMsg:  "required field",
        },
        {{range .Fields}}
        {{if ne .Name "Id"}}
        {
            name: "Error/Invalid{{.Name}}",
            request: &proto.Create{{.Name}}Request{
                {{range $.Fields}}
                {{if and (ne .Name "Id") (ne .Name $.Name)}}
                {{.Name}}: s.generateTestData("{{.Type}}").({{.Type}}),
                {{end}}
                {{end}}
                {{.Name}}: s.generateInvalidData("{{.Type}}").({{.Type}}),
            },
            wantErr:     true,
            wantErrCode: codes.InvalidArgument,
            wantErrMsg:  "invalid {{toLower .Name}}",
        },
        {{end}}
        {{end}}
        // Дубликаты
        {
            name: "Error/DuplicateUnique",
            request: &proto.Create{{.Name}}Request{
                {{range .Fields}}
                {{if ne .Name "Id"}}
                {{.Name}}: s.generateTestData("{{.Type}}").({{.Type}}),
                {{end}}
                {{end}}
            },
            setupFn: func() {
                // Создаем запись с теми же уникальными полями
                _, err := s.{{toLower .Name}}.Create(context.Background(), &proto.Create{{.Name}}Request{
                    {{range .Fields}}
                    {{if ne .Name "Id"}}
                    {{.Name}}: s.generateTestData("{{.Type}}").({{.Type}}),
                    {{end}}
                    {{end}}
                })
                s.Require().NoError(err)
            },
            wantErr:     true,
            wantErrCode: codes.AlreadyExists,
            wantErrMsg:  "already exists",
        },
        // Граничные случаи
        {
            name: "Success/MaxLengthValues",
            request: &proto.Create{{.Name}}Request{
                {{range .Fields}}
                {{if ne .Name "Id"}}
                {{.Name}}: s.generateString(255),
                {{end}}
                {{end}}
            },
            validate: func(t *testing.T, resp *proto.{{.Name}}, err error) {
                require.NoError(t, err)
                require.NotNil(t, resp)
                require.NotZero(t, resp.Id)
            },
        },
    }

    for _, tt := range tests {
        s.Run(tt.name, func() {
            s.cleanupDB()

            if tt.setupFn != nil {
                tt.setupFn()
            }

            resp, err := s.{{toLower .Name}}.Create(context.Background(), tt.request)

            if tt.wantErr {
                s.checkGRPCError(err, tt.wantErrCode, tt.wantErrMsg)
                return
            }

            if tt.validate != nil {
                tt.validate(s.T(), resp, err)
            }
        })
    }
}

// Get Tests
func (s *IntegrationTestSuite) Test{{.Name}}GetGRPC() {
    tests := []struct {
        name        string
        setupFn     func() int64 // возвращает ID созданной записи
        id          int64
        wantErr     bool
        wantErrCode codes.Code
        wantErrMsg  string
        validate    func(*testing.T, *proto.{{.Name}}, error)
    }{
        {
            name: "Success/ExistingID",
            setupFn: func() int64 {
                resp, err := s.{{toLower .Name}}.Create(context.Background(), &proto.Create{{.Name}}Request{
                    {{range .Fields}}
                    {{if ne .Name "Id"}}
                    {{.Name}}: s.generateTestData("{{.Type}}").({{.Type}}),
                    {{end}}
                    {{end}}
                })
                s.Require().NoError(err)
                return resp.Id
            },
            validate: func(t *testing.T, resp *proto.{{.Name}}, err error) {
                require.NoError(t, err)
                require.NotNil(t, resp)
                require.NotZero(t, resp.Id)
            },
        },
        {
            name:        "Error/NonExistentID",
            id:          999999,
            wantErr:     true,
            wantErrCode: codes.NotFound,
            wantErrMsg:  "not found",
        },
        {
            name:        "Error/InvalidID",
            id:          -1,
            wantErr:     true,
            wantErrCode: codes.InvalidArgument,
            wantErrMsg:  "invalid id",
        },
    }

    for _, tt := range tests {
        s.Run(tt.name, func() {
            s.cleanupDB()

            var id int64
            if tt.setupFn != nil {
                id = tt.setupFn()
            } else {
                id = tt.id
            }

            resp, err := s.{{toLower .Name}}.Get(context.Background(), &proto.Get{{.Name}}Request{Id: id})

            if tt.wantErr {
                s.checkGRPCError(err, tt.wantErrCode, tt.wantErrMsg)
                return
            }

            if tt.validate != nil {
                tt.validate(s.T(), resp, err)
            }
        })
    }
}

// List Tests
func (s *IntegrationTestSuite) Test{{.Name}}ListGRPC() {
    tests := []struct {
        name        string
        setupFn     func() // создает тестовые записи
        request     *proto.List{{.Name}}Request
        wantErr     bool
        wantErrCode codes.Code
        wantErrMsg  string
        validate    func(*testing.T, *proto.List{{.Name}}Response, error)
    }{
        {
            name: "Success/EmptyList",
            request: &proto.List{{.Name}}Request{},
            validate: func(t *testing.T, resp *proto.List{{.Name}}Response, err error) {
                require.NoError(t, err)
                require.NotNil(t, resp)
                require.Empty(t, resp.Items)
            },
        },
        {
            name: "Success/MultipleItems",
            setupFn: func() {
                // Создаем 3 записи
                for i := 0; i < 3; i++ {
                    _, err := s.{{toLower .Name}}.Create(context.Background(), &proto.Create{{.Name}}Request{
                        {{range .Fields}}
                        {{if ne .Name "Id"}}
                        {{.Name}}: s.generateTestData("{{.Type}}").({{.Type}}),
                        {{end}}
                        {{end}}
                    })
                    s.Require().NoError(err)
                }
            },
            request: &proto.List{{.Name}}Request{},
            validate: func(t *testing.T, resp *proto.List{{.Name}}Response, err error) {
                require.NoError(t, err)
                require.NotNil(t, resp)
                require.Len(t, resp.Items, 3)
                for _, item := range resp.Items {
                    require.NotZero(t, item.Id)
                }
            },
        },
        {
            name: "Success/WithPagination",
            setupFn: func() {
                // Создаем 5 записей
                for i := 0; i < 5; i++ {
                    _, err := s.{{toLower .Name}}.Create(context.Background(), &proto.Create{{.Name}}Request{
                        {{range .Fields}}
                        {{if ne .Name "Id"}}
                        {{.Name}}: s.generateTestData("{{.Type}}").({{.Type}}),
                        {{end}}
                        {{end}}
                    })
                    s.Require().NoError(err)
                }
            },
            request: &proto.List{{.Name}}Request{
                Limit:  2,
                Offset: 1,
            },
            validate: func(t *testing.T, resp *proto.List{{.Name}}Response, err error) {
                require.NoError(t, err)
                require.NotNil(t, resp)
                require.Len(t, resp.Items, 2)
            },
        },
    }

    for _, tt := range tests {
        s.Run(tt.name, func() {
            s.cleanupDB()

            if tt.setupFn != nil {
                tt.setupFn()
            }

            resp, err := s.{{toLower .Name}}.List(context.Background(), tt.request)

            if tt.wantErr {
                s.checkGRPCError(err, tt.wantErrCode, tt.wantErrMsg)
                return
            }

            if tt.validate != nil {
                tt.validate(s.T(), resp, err)
            }
        })
    }
}

// Update Tests
func (s *IntegrationTestSuite) Test{{.Name}}UpdateGRPC() {
    tests := []struct {
        name        string
        setupFn     func() int64 // возвращает ID для обновления
        request     *proto.Update{{.Name}}Request
        wantErr     bool
        wantErrCode codes.Code
        wantErrMsg  string
        validate    func(*testing.T, *proto.{{.Name}}, error)
    }{
        {
            name: "Success/FullUpdate",
            setupFn: func() int64 {
                resp, err := s.{{toLower .Name}}.Create(context.Background(), &proto.Create{{.Name}}Request{
                    {{range .Fields}}
                    {{if ne .Name "Id"}}
                    {{.Name}}: s.generateTestData("{{.Type}}").({{.Type}}),
                    {{end}}
                    {{end}}
                })
                s.Require().NoError(err)
                return resp.Id
            },
            request: &proto.Update{{.Name}}Request{
                {{range .Fields}}
                {{if ne .Name "Id"}}
                {{.Name}}: s.generateTestData("{{.Type}}").({{.Type}}),
                {{end}}
                {{end}}
            },
            validate: func(t *testing.T, resp *proto.{{.Name}}, err error) {
                require.NoError(t, err)
                require.NotNil(t, resp)
                {{range .Fields}}
                {{if ne .Name "Id"}}
                require.NotEmpty(t, resp.{{.Name}})
                {{end}}
                {{end}}
            },
        },
        {
            name:        "Error/NonExistentID",
            request:     &proto.Update{{.Name}}Request{Id: 999999},
            wantErr:     true,
            wantErrCode: codes.NotFound,
            wantErrMsg:  "not found",
        },
        {
            name: "Error/InvalidFields",
            setupFn: func() int64 {
                resp, err := s.{{toLower .Name}}.Create(context.Background(), &proto.Create{{.Name}}Request{
                    {{range .Fields}}
                    {{if ne .Name "Id"}}
                    {{.Name}}: s.generateTestData("{{.Type}}").({{.Type}}),
                    {{end}}
                    {{end}}
                })
                s.Require().NoError(err)
                return resp.Id
            },
            request: &proto.Update{{.Name}}Request{
                {{range .Fields}}
                {{if ne .Name "Id"}}
                {{.Name}}: s.generateInvalidData("{{.Type}}").({{.Type}}),
                {{end}}
                {{end}}
            },
            wantErr:     true,
            wantErrCode: codes.InvalidArgument,
            wantErrMsg:  "invalid",
        },
    }

    for _, tt := range tests {
        s.Run(tt.name, func() {
            s.cleanupDB()

            var id int64
            if tt.setupFn != nil {
                id = tt.setupFn()
            }
            if tt.request != nil {
                tt.request.Id = id
            }

            resp, err := s.{{toLower .Name}}.Update(context.Background(), tt.request)

            if tt.wantErr {
                s.checkGRPCError(err, tt.wantErrCode, tt.wantErrMsg)
                return
            }

            if tt.validate != nil {
                tt.validate(s.T(), resp, err)
            }
        })
    }
}

// Delete Tests
func (s *IntegrationTestSuite) Test{{.Name}}DeleteGRPC() {
    tests := []struct {
        name        string
        setupFn     func() int64 // возвращает ID для удаления
        id          int64
        wantErr     bool
        wantErrCode codes.Code
        wantErrMsg  string
        validate    func(*testing.T, error)
    }{
        {
            name: "Success/ExistingID",
            setupFn: func() int64 {
                resp, err := s.{{toLower .Name}}.Create(context.Background(), &proto.Create{{.Name}}Request{
                    {{range .Fields}}
                    {{if ne .Name "Id"}}
                    {{.Name}}: s.generateTestData("{{.Type}}").({{.Type}}),
                    {{end}}
                    {{end}}
                })
                s.Require().NoError(err)
                return resp.Id
            },
            validate: func(t *testing.T, err error) {
                require.NoError(t, err)
                // Проверяем что запись действительно удалена
                _, err = s.{{toLower .Name}}.Get(context.Background(), &proto.Get{{.Name}}Request{Id: 1})
                require.Error(t, err)
                st, ok := status.FromError(err)
                require.True(t, ok)
                require.Equal(t, codes.NotFound, st.Code())
            },
        },
        {
            name:        "Error/NonExistentID",
            id:          999999,
            wantErr:     true,
            wantErrCode: codes.NotFound,
            wantErrMsg:  "not found",
        },
        {
            name:        "Error/InvalidID",
            id:          -1,
            wantErr:     true,
            wantErrCode: codes.InvalidArgument,
            wantErrMsg:  "invalid id",
        },
    }

    for _, tt := range tests {
        s.Run(tt.name, func() {
            s.cleanupDB()

            var id int64
            if tt.setupFn != nil {
                id = tt.setupFn()
            } else {
                id = tt.id
            }

            _, err := s.{{toLower .Name}}.Delete(context.Background(), &proto.Delete{{.Name}}Request{Id: id})

            if tt.wantErr {
                s.checkGRPCError(err, tt.wantErrCode, tt.wantErrMsg)
                return
            }

            if tt.validate != nil {
                tt.validate(s.T(), err)
            }
        })
    }
}

func (s *IntegrationTestSuite) Test{{.Name}}GRPC() {
    // Create tests
    s.Run("Create", func() {
        s.cleanupDB()
        
        resp, err := s.{{toLower .Name}}.Create(context.Background(), &proto.Create{{.Name}}Request{
            {{range .Fields}}
            {{if ne .Name "Id"}}
            {{.Name}}: s.generateTestData("{{.Type}}").({{.Type}}),
            {{end}}
            {{end}}
        })
        s.Require().NoError(err)
        s.Require().NotNil(resp)
        s.Require().NotZero(resp.Id)
    })

    // Get tests
    s.Run("Get", func() {
        s.cleanupDB()
        
        // Create test data first
        createResp, err := s.{{toLower .Name}}.Create(context.Background(), &proto.Create{{.Name}}Request{
            {{range .Fields}}
            {{if ne .Name "Id"}}
            {{.Name}}: s.generateTestData("{{.Type}}").({{.Type}}),
            {{end}}
            {{end}}
        })
        s.Require().NoError(err)

        resp, err := s.{{toLower .Name}}.Get(context.Background(), &proto.Get{{.Name}}Request{
            Id: createResp.Id,
        })
        s.Require().NoError(err)
        s.Require().NotNil(resp)
        s.Require().Equal(createResp.Id, resp.Id)
    })
}
{{end}} 